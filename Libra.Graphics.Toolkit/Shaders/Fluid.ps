// 参考: GPU Gems 2 - Chapter 19. Generic Refraction Simulation
//
// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter19.html

cbuffer PerCamera : register(b0)
{
    float3 EyePosition;
};

cbuffer PerObject : register(b1)
{
    float3 FluidColor               : packoffset(c0);
    bool   FluidColorBlendEnabled   : packoffset(c0.w);
    float  FluidColorBlendDistance  : packoffset(c1);
    float  RippleScale              : packoffset(c1.y);
    bool   RefractionMapEnabled     : packoffset(c2);
    bool   ReflectionMapEnabled     : packoffset(c2.y);
    float  ReflectionCoeff          : packoffset(c2.z);
};

cbuffer PerFrame : register(b2)
{
    float2 Offset;
};

Texture2D<float3> NormalMap     : register(t0);
Texture2D<float3> ReflectionMap : register(t1);
Texture2D<float3> RefractionMap : register(t2);

SamplerState NormalMapSampler       : register(s0);
SamplerState ReflectionMapSampler   : register(s1);
SamplerState RefractionMapSampler   : register(s2);

struct Input
{
    float4 Position     : SV_Position;
    float2 TexCoord     : TEXCOORD0;
    float4 PositionW    : TEXCOORD1;
    float4 PositionWVP  : TEXCOORD2;
    float4 PositionWRP  : TEXCOORD3;
};

struct Output
{
    float4 Color : SV_Target0;
};

float2 ToTexCoord(float4 position)
{
    return position.xy / position.w * float2(0.5, -0.5) + float2(0.5, 0.5);
}

// フレネルの式 (Fresnel term): Schlick の近似 (Schlick's approximation)
float Fresnel(float nDotL, float reflectionCoeff)
{
    float fresnel = reflectionCoeff + (1.0f - reflectionCoeff) * pow(1.0f - nDotL, 5.0);
    return max(0, fresnel);
}

Output PS(Input input)
{
    Output output;

    float2 texCoord = input.TexCoord + Offset;

    float3 normal = NormalMap.SampleLevel(NormalMapSampler, texCoord, 0);
    normal = normalize(normal);

    float3 positionToEye = EyePosition - input.PositionW.xyz;
    float eyeDistance = length(positionToEye);
    float3 e = normalize(positionToEye);
    float nDotL = dot(e, normal);

    float3 color;

    if (RefractionMapEnabled)
    {
        // 屈折マップ。
        float2 refractionTexCoord = ToTexCoord(input.PositionWVP);
        refractionTexCoord += normal.xz * RippleScale;
        float3 refractionColor = RefractionMap.Sample(RefractionMapSampler, refractionTexCoord);

        if (FluidColorBlendEnabled)
        {
            // 視点が遠い程に屈折は見えなくなり流体の色となる。
            // 流体の色を掛け合わせ始める距離が FluidColorBlendDistance。

            float distanceScale = saturate(FluidColorBlendDistance / eyeDistance);
            color = lerp(FluidColor, refractionColor, distanceScale);

            // 視点と法線が垂直に近い程に流体の色が見える。
            // 並行、すなわち、真上から見る程に、流体の色よりも流体の中が見える。

            float facing = 1 - nDotL;
            color = lerp(color, FluidColor, facing);
        }
        else
        {
            color = refractionColor;
        }
    }
    else
    {
        // 屈折マップ未使用ならば流体色を設定。
        color = FluidColor;
    }

    if (ReflectionMapEnabled)
    {
        // 反射マップ。
        float2 reflectionTexCoord = ToTexCoord(input.PositionWRP);
        reflectionTexCoord += normal.xz * RippleScale;
        float3 reflactionColor = ReflectionMap.Sample(ReflectionMapSampler, reflectionTexCoord);

        // フレネルの式に従い反射による色を決定し、これまでの流体色と合成。
        float fresnel = Fresnel(nDotL, ReflectionCoeff);
        output.Color = float4(fresnel * reflactionColor + color, 1);
    }
    else
    {
        // 反射マップ未使用ならば、これまでの流体色を設定。
        output.Color = float4(color, 1);
    }

    return output;
}
