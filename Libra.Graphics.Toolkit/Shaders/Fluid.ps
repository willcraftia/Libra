// 参考: GPU Gems 2 - Chapter 19. Generic Refraction Simulation
//
// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter19.html

cbuffer PerObject : register(b0)
{
    // rgb: 拡散反射光 (乗算済みアルファ)。
    // a:   アルファ。
    float4   DiffuseColor           : packoffset(c0);

    // 環境光加算済み放射光。
    float3   EmissiveColor          : packoffset(c1);

    float3   SpecularColor          : packoffset(c2);
    float    SpecularPower          : packoffset(c2.w);

    float    RippleScale            : packoffset(c3);

    bool     RefractionMapEnabled   : packoffset(c4);
    float    RefractionAttenuation  : packoffset(c4.y);
    bool     ReflectionMapEnabled   : packoffset(c4.z);
    float    ReflectionCoeff        : packoffset(c4.w);

    float4x4 WorldView              : packoffset(c5);
};

cbuffer PerFrame : register(b1)
{
    float2 Offset0          : packoffset(c0);
    float2 Offset1          : packoffset(c0.z);

    float3 LightDirection   : packoffset(c1);
};

Texture2D<float3> NormalMap0    : register(t0);
Texture2D<float3> NormalMap1    : register(t1);
Texture2D<float3> ReflectionMap : register(t2);
Texture2D<float3> RefractionMap : register(t3);

SamplerState NormalMapSampler       : register(s0);
SamplerState ReflectionMapSampler   : register(s1);
SamplerState RefractionMapSampler   : register(s2);

struct Input
{
    float4 Position     : SV_Position;
    float2 TexCoord     : TEXCOORD0;
    float4 PositionWV   : TEXCOORD1;
    float4 PositionWVP  : TEXCOORD2;
    float4 PositionWRP  : TEXCOORD3;
};

float2 ToTexCoord(float4 position)
{
    return position.xy / position.w * float2(0.5, -0.5) + float2(0.5, 0.5);
}

// フレネルの式 (Fresnel term): Schlick の近似 (Schlick's approximation)
float Fresnel(float nDotL, float reflectionCoeff)
{
    float fresnel = reflectionCoeff + (1.0f - reflectionCoeff) * pow(1.0f - nDotL, 5.0);
    return max(0, fresnel);
}

float4 PS(Input input) : SV_Target0
{
    float2 texCoord0 = input.TexCoord + Offset0;
    float2 texCoord1 = input.TexCoord + Offset1;
    float3 normal0 = NormalMap0.SampleLevel(NormalMapSampler, texCoord0, 0);
    float3 normal1 = NormalMap1.SampleLevel(NormalMapSampler, texCoord1, 0);

    // サンプリングした二つの法線の平均。
    float3 normal = (normal0 + normal1) / 2;

    // 法線 (ビュー空間)。
    float3 N = normalize(mul(normal, (float3x3) WorldView));

    // 面から視点までの距離。
    float eyeDistance = length(input.PositionWV.xyz);

    // 面から視点への単位ベクトル (ビュー空間)。
    float3 E = normalize(-input.PositionWV.xyz);

    // 視点と法線のなす角。
    float nDotE = max(dot(E, N), 0);

    float3 color = float3(0, 0, 0);

    if (RefractionMapEnabled)
    {
        // 屈折マップ。
        float2 refractionTexCoord = ToTexCoord(input.PositionWVP);
        refractionTexCoord += normal.xz * RippleScale;
        float3 refractionColor = RefractionMap.Sample(RefractionMapSampler, refractionTexCoord);

        // 視点が遠い程に流体内 (屈折) は見えなくなる。
        // RefractionAttenuation は減衰開始距離。

        float distanceScale = saturate(RefractionAttenuation / eyeDistance);
        color = refractionColor * distanceScale;

        // 視点と法線が垂直に近い程に流体内 (屈折) が見えなくなる。
        // 並行である程に流体内が見える。

        color *= nDotE;
    }

    if (ReflectionMapEnabled)
    {
        // 反射マップ。
        float2 reflectionTexCoord = ToTexCoord(input.PositionWRP);
        reflectionTexCoord += normal.xz * RippleScale;
        float3 reflactionColor = ReflectionMap.Sample(ReflectionMapSampler, reflectionTexCoord);

        // フレネルの式に従い反射による色を決定して合成。
        // ここでは視線を入射光とし、法線と視線の内積から算出。
        float fresnel = Fresnel(nDotE, ReflectionCoeff);
        color += fresnel * reflactionColor;
    }

    float3 L = mul(-LightDirection, (float3x3) WorldView);
    float nDotL = dot(L, N);

    float3 diffuse = max(0, nDotL) * DiffuseColor.rgb;
    color += diffuse;

    color += EmissiveColor;

    float3 R = normalize(reflect(-E, N));
    float3 specular = pow(max(0, dot(R, L)), SpecularPower) * SpecularColor;
    color += specular;

    return float4(color, DiffuseColor.a);
}
