// 参考: GPU Gems 2 - Chapter 19. Generic Refraction Simulation
//
// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter19.html

cbuffer PerObject : register(b0)
{
    float4   FluidColor                 : packoffset(c0);
    bool     FluidColorBlendEnabled     : packoffset(c1);
    float    FluidColorBlendDistance    : packoffset(c1.y);
    float    RippleScale                : packoffset(c1.z);
    bool     RefractionMapEnabled       : packoffset(c2);
    bool     ReflectionMapEnabled       : packoffset(c2.y);
    float    ReflectionCoeff            : packoffset(c2.z);
    float4x4 WorldView                  : packoffset(c3);
};

cbuffer PerFrame : register(b1)
{
    float2 Offset0          : packoffset(c0);
    float2 Offset1          : packoffset(c0.z);
    float3 SpecularColor    : packoffset(c1);
    float  SpecularPower    : packoffset(c1.w);
    float3 LightDirection   : packoffset(c2);
};

Texture2D<float3> NormalMap0    : register(t0);
Texture2D<float3> NormalMap1    : register(t1);
Texture2D<float3> ReflectionMap : register(t2);
Texture2D<float3> RefractionMap : register(t3);

SamplerState NormalMapSampler       : register(s0);
SamplerState ReflectionMapSampler   : register(s1);
SamplerState RefractionMapSampler   : register(s2);

struct Input
{
    float4 Position     : SV_Position;
    float2 TexCoord     : TEXCOORD0;
    float4 PositionWV   : TEXCOORD1;
    float4 PositionWVP  : TEXCOORD2;
    float4 PositionWRP  : TEXCOORD3;
};

float2 ToTexCoord(float4 position)
{
    return position.xy / position.w * float2(0.5, -0.5) + float2(0.5, 0.5);
}

// フレネルの式 (Fresnel term): Schlick の近似 (Schlick's approximation)
float Fresnel(float nDotL, float reflectionCoeff)
{
    float fresnel = reflectionCoeff + (1.0f - reflectionCoeff) * pow(1.0f - nDotL, 5.0);
    return max(0, fresnel);
}

float4 PS(Input input) : SV_Target0
{
    float2 texCoord0 = input.TexCoord + Offset0;
    float2 texCoord1 = input.TexCoord + Offset1;
    float3 normal0 = NormalMap0.SampleLevel(NormalMapSampler, texCoord0, 0);
    float3 normal1 = NormalMap1.SampleLevel(NormalMapSampler, texCoord1, 0);

    // サンプリングした二つの法線の平均。
    float3 normal = (normal0 + normal1) / 2;

    // 法線 (ビュー空間)。
    float3 N = normalize(mul(normal, (float3x3) WorldView));

    // 面から視点までの距離。
    float eyeDistance = length(input.PositionWV.xyz);

    // 面から視点への単位ベクトル (ビュー空間)。
    float3 E = normalize(-input.PositionWV.xyz);

    // 視点と法線のなす角。
    float nDotL = max(dot(E, N), 0);

    float3 color;

    if (RefractionMapEnabled)
    {
        // 屈折マップ。
        float2 refractionTexCoord = ToTexCoord(input.PositionWVP);
        refractionTexCoord += normal.xz * RippleScale;
        float3 refractionColor = RefractionMap.Sample(RefractionMapSampler, refractionTexCoord);

        if (FluidColorBlendEnabled)
        {
            // 視点が遠い程に屈折は見えなくなり流体の色となる。
            // 流体の色を掛け合わせ始める距離が FluidColorBlendDistance。

            float distanceScale = saturate(FluidColorBlendDistance / eyeDistance);
            color = lerp(FluidColor.rgb, refractionColor, distanceScale);

            // 視点と法線が垂直に近い程に流体の色が見える。
            // 並行、すなわち、真上から見る程に、流体の色よりも流体の中が見える。

            float facing = 1 - nDotL;
            color = lerp(color, FluidColor.rgb, facing);
        }
        else
        {
            color = refractionColor;
        }
    }
    else
    {
        // 屈折マップ未使用ならば流体色を設定。
        color = FluidColor.rgb;
    }

    if (ReflectionMapEnabled)
    {
        // 反射マップ。
        float2 reflectionTexCoord = ToTexCoord(input.PositionWRP);
        reflectionTexCoord += normal.xz * RippleScale;
        float3 reflactionColor = ReflectionMap.Sample(ReflectionMapSampler, reflectionTexCoord);

        // フレネルの式に従い反射による色を決定し、これまでの流体色と合成。
        float fresnel = Fresnel(nDotL, ReflectionCoeff);
        color += fresnel * reflactionColor;
    }

    float3 L = mul(-LightDirection, (float3x3) WorldView);
    float3 R = normalize(reflect(input.PositionWV.xyz, N));
    float3 specular = pow(max(dot(R, L), 0), SpecularPower) * SpecularColor;
    color += specular;

    return float4(color, FluidColor.a);
}
