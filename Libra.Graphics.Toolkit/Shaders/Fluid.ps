// 参考: GPU Gems 2 - Chapter 19. Generic Refraction Simulation
//
// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter19.html

cbuffer PerCamera : register(b0)
{
    float3 EyePosition;
};

cbuffer PerObject : register(b1)
{
    float  RippleScale              : packoffset(c0);
    float3 FluidColor               : packoffset(c0.y);
    float3 FluidDeepColor           : packoffset(c1);
    float  FluidDeepColorDistance   : packoffset(c1.w);
    bool   FluidColorEnabled        : packoffset(c2);
    bool   FluidDeepColorEnabled    : packoffset(c2.y);
    float  ReflectionCoeff          : packoffset(c2.z);
};

cbuffer PerFrame : register(b2)
{
    float2 Offset;
};

Texture2D<float3> NormalMap     : register(t0);
Texture2D<float3> ReflectionMap : register(t1);
Texture2D<float3> RefractionMap : register(t2);

SamplerState NormalMapSampler       : register(s0);
SamplerState ReflectionMapSampler   : register(s1);
SamplerState RefractionMapSampler   : register(s2);

struct Input
{
    float4 Position     : SV_Position;
    float2 TexCoord     : TEXCOORD0;
    float4 PositionW    : TEXCOORD1;
    float4 PositionWVP  : TEXCOORD2;
    float4 PositionWRP  : TEXCOORD3;
};

struct Output
{
    float4 Color : SV_Target0;
};

float2 ToTexCoord(float4 position)
{
    return position.xy / position.w * float2(0.5, -0.5) + float2(0.5, 0.5);
}

// フレネルの式 (Fresnel term): Schlick の近似 (Schlick's approximation)
float Fresnel(float nDotL, float reflectionCoeff)
{
    float fresnel = reflectionCoeff + (1.0f - reflectionCoeff) * pow(1.0f - nDotL, 5.0);
    return max(0, fresnel);
}

Output PS(Input input)
{
    Output output;

    float2 texCoord = input.TexCoord + Offset;

    float3 normal = NormalMap.SampleLevel(NormalMapSampler, texCoord, 0);
    normal = normalize(normal);

    float3 positionToEye = EyePosition - input.PositionW.xyz;
    float eyeDistance = length(positionToEye);

    float3 color;

    // 屈折マップ。
    float2 refractionTexCoord = ToTexCoord(input.PositionWVP);
    refractionTexCoord += normal.xz * RippleScale;
    float3 refractionColor = RefractionMap.Sample(RefractionMapSampler, refractionTexCoord);

    if (FluidDeepColorEnabled)
    {
        // 視点が遠い程に屈折は見えなくなり、深い流体の色となる。
        // 深い流体の色を掛け合わせ始める距離が FluidDeepColorDistance。

        float distanceScale = saturate(FluidDeepColorDistance / eyeDistance);
        color = lerp(FluidDeepColor, refractionColor, distanceScale);
    }
    else
    {
        color = refractionColor;
    }

    float3 e = normalize(positionToEye);
    float nDotL = dot(e, normal);

    if (FluidColorEnabled)
    {
        // 視点と法線が垂直に近い程に流体の色が見える。
        // 並行、すなわち、真上から見る程に、流体の色よりも流体の中が見える。

        float facing = 1 - nDotL;
        color = lerp(color, FluidColor, facing);
    }

    // 反射マップ。
    float2 reflectionTexCoord = ToTexCoord(input.PositionWRP);
    reflectionTexCoord += normal.xz * RippleScale;
    float3 reflactionColor = ReflectionMap.Sample(ReflectionMapSampler, reflectionTexCoord);

    // フレネルの式に従い反射による色を決定し、これまでの流体の色と合成。
    float fresnel = Fresnel(nDotL, ReflectionCoeff);
    output.Color = float4(fresnel * reflactionColor + color, 1);

    // 以下はフレネルの式のテスト用。
//    output.Color = float4(lerp(reflactionColor, refractionColor, fresnel), 1);

    return output;
}
